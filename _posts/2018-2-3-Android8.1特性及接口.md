---
layout: post
title: "Android8.1ÁâπÊÄßÂèäÊé•Âè£"
subtitle: "ÁúãAndroidÁöÑÂèëÂ±ï"
date: 2018-2-7 11:00:00
author: "Himself65"
header-img: "img/head_post/2018-02-03-01.png"
darktheme: true
tags: 
    - ËΩ¨ËΩΩ
    - ÁøªËØë
    - Ëã±ËØ≠Â≠¶‰π†
---
# Android8.1ÁâπÊÄßÂèäÊé•Âè£

[ÂéüÊñáÂú∞ÂùÄ](https://developer.android.com/about/versions/oreo/android-8.1.html)

‰ª•‰∏ãÂÜÖÂÆπ‰∏∫Himself65ÁøªËØëÔºåËã±ËØ≠È©¨È©¨ËôéËôéËØ∑ÊåáÂá∫ÈóÆÈ¢òË∞¢Ë∞¢üôè

## Android Oreo (Go ÁâàÊú¨)

Êàë‰ª¨Âú®Android Go‰∏≠ÂºÄÂßãÂéª‰ºòÂåñ‰∏ñÁïåÂêÑÂú∞ÂÆâÂçìÁî®Êà∑ÁöÑ‰∏äÁΩë‰ΩìÈ™å„ÄÇ‰ªéAndroid8.1ÂºÄÂßãÔºåÊàë‰ª¨Ê≠£‰ΩøÂÆâÂçì‰Ωú‰∏∫ÂÖ•Èó®Á∫ßËÆæÂ§áÁöÑ‰∏Ä‰∏™Âº∫Â§ßÂπ≥Âè∞„ÄÇÂú®Êú™Êù•ÁöÑAndroid Oreo (Go edition)ÁâàÊú¨‰∏≠Êàë‰ª¨‰ºöÂä†ÂÖ•Ôºö

- **ÂÜÖÂ≠ò‰ºòÂåñ**„ÄÇÊèêÂçá‰∫ÜÂÜÖÂ≠ò‰ΩøÁî®ÊïàÁéáÔºåËÆ©AppËÉΩÂú®1GBÊàñÊõ¥Â∞ëÂÜÖÂ≠ò‰∏ãÊúâÊïàÁéáËøêË°å

- **ÁÅµÊ¥ªÂåñÁöÑÁõÆÊ†áÈÄâÈ°π**„ÄÇÊñ∞ÁöÑÁ°¨‰ª∂Â∏∏ÈáèÔºå‰Ωø‰Ω†Êõ¥Â•ΩÁöÑÂàÜÈÖç‰Ω†ÁöÑAppÈÄöËøáGoogle PlayÂú®ËÆæÂ§áÂÜÖÂ≠òÊ≠£Â∏∏Êàñ‰ΩéÂÜÖÂ≠òÁä∂ÊÄÅ‰∏ã

- **Google Play**„ÄÇÊâÄÊúâAppÈÉΩËÉΩÂú®Android Oreo (Go edition)‰∏äËøêË°å„ÄÇGoogle Play‰ºöÊèêÂçá‰∏ìÈó®‰ºòÂåñËøáÁöÑAppÂèØËßÅÊÄßÔºåËøôÊ†∑ÁªôÊï∞ÂçÅ‰∫ø‰∫∫Áªù‰Ω≥ÁöÑÁî®Êà∑‰ΩìÈ™åÔºåÂπ∂ÁªôÂºÄÂèëËÄÖÊèê‰æõ‰∏∞ÂØåÁöÑÁî®Êà∑‰ΩìÈ™åÊåáÂØºÊñπÊ°à

Êàë‰ª¨Â∑≤ÁªèÊõ¥Êñ∞‰∫ÜÁî®Êà∑‰ΩìÈ™åÊåáÂØºÊñπÊ°àÂú® Â¶Ç‰ΩïÂú®Êñ∞Android‰∏ä‰ºòÂåñÊÇ®AppÁöÑËøêÂ≠ò„ÄÇÂØπ‰∫éÂ§ßÂ§öÊï∞ÂºÄÂèëËÄÖËÄåË®ÄÔºå‰ºòÂåñ‰Ω†Áé∞Âú®ÁöÑApkÊàñËÄÖÊòØ‰ΩøÁî®Ë∞∑Ê≠åÂïÜÂ∫óÁöÑÂ§öÂÖÉÂåñApkÁâπÊÄßÊù•ÈíàÂØπ‰Ω†ApkÂú®‰ΩéÂÜÖÂ≠òÁä∂ÊÄÅ‰∏ãÁöÑÊúÄÂ•ΩÁöÑÂäûÊ≥ïÂ∞±ÊòØÂéªË£Ö‰∏Ä‰∏™Android Oreo

## Á•ûÁªèÁΩëÁªúAPI

Á•ûÁªèÁΩëÁªúAPIÁªôÂú®ËÆæÂ§á‰∏äÁöÑÂ≠¶‰π†Ê°ÜÊû∂ÊØîÂ¶ÇTensorFlow LiteÔºàGoogleÁöÑË∑®Âπ≥Âè∞ÊâãÊú∫MLÂ∫ì„ÄÅCaffe2Á≠âÔºâ Êèê‰æõ‰∫ÜÂä†ÈÄüËÆ°ÁÆóÂíåÈÄªËæëÊé®ÁêÜÂäüËÉΩ„ÄÇËÆøÈóÆTensorFlow LiteÂºÄÊ∫êÂ∫ìÊù•‰∏ãËΩΩÂíåÊü•ÊâæÊñáÁåÆ„ÄÇTensorFlow Lite‰∏éNeuralÁΩëÁªúAPIÂêà‰ΩúÊù•Âú®‰Ω†ÊâãÊú∫‰∏äÊõ¥ÊúâÊïàÁéáÁöÑË∑ë‰∏Ä‰∫õÂÉèMob lieNet„ÄÅInception v3„ÄÅSmart ReplyÁ≠âÊ®°Âûã„ÄÇ

## Ëá™Âä®Â°´ÂÖÖÊ°ÜÊû∂Êõ¥Êñ∞

Android 8.1 (API level 27) provides several improvements to the Autofill Framework that you can incorporate into your apps.

The BaseAdapter class now includes the setAutofillOptions() method, which allows you to provide string representations of the values in an adapter. This is useful for spinner controls that dynamically generate the values in their adapters. For example, you can use the setAutofillOptions() method to provide a string representation of the list of years that the users can choose as part of a credit card expiration date. Autofill services can use the string representation to appropriately fill out the views that require the data.

Additionally, the AutofillManager class includes the notifyViewVisibilityChanged(View, int, boolean) method that you can call to notify the framework about changes in the visibility of a view in a virtual structure. There's also an overload of the method for non virtual structures. However, non virtual structures usually don't require you to explicitly notify the framework because the method is already called by the View class.

Android 8.1 also gives Autofill Services more ability to customize the save UI affordance by adding support for CustomDescription and Validator within SaveInfo.

Custom descriptions are useful to help the autofill service clarify what is being saved; for example, when the screen contains a credit card, it could display a logo of the credit card bank, the last four digits of the credit card number, and its expiration number. To learn more, see the CustomDescription class.

Validator objects are used to avoid displaying the autofill save UI when the Validator condition isn't satisfied. To learn more, see the Validator class along with its subclasses, LuhnChecksumValidator and RegexValidator.

## Ê∂àÊÅØÈÄöÁü•

Andorid 8.1ÁöÑÊ∂àÊÅØÈÄöÁü•ÂåÖÂê´‰∫ÜËøô‰∫õÊîπÂèòÔºö

- Â∫îÁî®Áé∞Âú®ÂèØ‰ª•Ëá™ÂÆö‰πâ‰∏Ä‰∏§‰∏™‰∏Ä‰∏§ÁßíÁöÑÊ∂àÊÅØÈÄöÁü•Â£∞Èü≥„ÄÇÈÄöÁü•Â£∞Èü≥Ëã•‰∏çÁ¨¶ÂêàË¶ÅÊ±ÇÂàô‰∏ç‰ºöÊ≥®ÂÜåÂêéÂè∞Âπ∂‰∏î‰∏¢Â§±„ÄÇËøô‰∏ÄÈ°πÊîπÂèò‰∏ç‰ºöÂΩ±ÂìçÈÄöÁü•Ë°å‰∏∫ÁöÑÂÖ∂‰ªñÊñπÈù¢Âπ∂‰∏îÈÄöÁü•ÈÇÆ‰ª∂‰ªçÊåâÈ¢ÑÊúüÂèëÂ∏É„ÄÇ

- ÂΩìË∞ÉÁî®activitymanager.islowramdeviceÔºàÔºâÊó∂ÔºåÂ¶ÇÊûúÂú®‰ΩéÂäüËÄóÁöÑandroidËÆæÂ§á‰∏ä‰∏çÊîØÊåÅnotificationlistenerserviceÂíåconditionproviderserviceÔºåËøîÂõûtrue„ÄÇ

## ÂØåÊñáÊú¨ÁºñËæëÊõ¥Êñ∞

Beginning with API level 27, the EditText.getText() method returns an Editable; previously it returned a CharSequence. This change is backward-compatible, as Editable implements CharSequence.

The Editable interface provides valuable additional functionality. For example, because Editable also implements the Spannable interface, you can apply markup to content within an instance of EditText.

## Á®ãÂ∫èÂåñÁöÑÂÆâÂÖ®ÊµèËßàÁΩëÁ´ôÊìç‰Ωú

By using the WebView implementation of the Safe Browsing API, your app can detect when an instance of WebView attempts to navigate to a URL that Google has classified as a known threat. By default, the WebView shows an interstitial that warns users of the known threat. This screen gives users the option to load the URL anyway or return to a previous page that's safe.

In Android 8.1, you can define programmatically how your app responds to a known threat:

- You can control whether your app reports known threats to Safe Browsing.

- You can have your app automatically perform a particular action‚Äîsuch as going back to safety‚Äîeach time it encounters a URL that Safe Browsing classifies as a known threat.

> Note: For optimal protection against known threats, wait until you've initialized Safe Browsing before you invoke a WebView object's loadUrl() method.

The following code snippets show how you can instruct your app's instances of WebView to always go back to safety after encountering a known threat:

> AndroidManifest.xml

``` xml
<manifest>
    <application>
        ...
        <meta-data android:name="android.webkit.WebView.EnableSafeBrowsing"
                   android:value="true" />
    </application>
</manifest>
```

> MyWebActivity.java

``` java
private WebView mSuperSafeWebView;
private boolean mSafeBrowsingIsInitialized;

// ...

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    mSuperSafeWebView = new WebView(this);
    mSuperSafeWebView.setWebViewClient(new MyWebViewClient());
    mSafeBrowsingIsInitialized = false;

    mSuperSafeWebView.startSafeBrowsing(this, new ValueCallback<Boolean>() {
        @Override
        public void onReceiveValue(Boolean success) {
            mSafeBrowsingIsInitialized = true;
            if (!success) {
                Log.e("MY_APP_TAG", "Unable to initialize Safe Browsing!");
            }
        }
    });
}
```

> MyWebViewClient.java

``` java
public class MyWebViewClient extends WebViewClient {
    // Automatically go "back to safety" when attempting to load a website that
    // Safe Browsing has identified as a known threat. An instance of WebView
    // calls this method only after Safe Browsing is initialized, so there's no
    // conditional logic needed here.
    @Override
    public void onSafeBrowsingHit(WebView view, WebResourceRequest request,
            int threatType, SafeBrowsingResponse callback) {
        // The "true" argument indicates that your app reports incidents like
        // this one to Safe Browsing.
        callback.backToSafety(true);
        Toast.makeText(view.getContext(), "Unsafe web page blocked.",
                Toast.LENGTH_LONG).show();
    }
}
```

## ËßÜÈ¢ëÁº©Áï•ÂõæÊèêÂèñ

The MediaMetadataRetriever class has a new method, getScaledFrameAtTime(), that finds a frame near a given time position and returns a bitmap with the same aspect ratio as the source frame, but scaled to fit into a rectangle of given width and height. This is useful for generating thumbnail images from video.

We recommend using this method rather than getFrameAtTime() which can waste memory because it returns a bitmap with the same resolution as the source video. For example, a frame from a 4K video would be a 16MB bitmap, far larger than you would need for a thumbnail image.

## ÂÜÖÂ≠òÂÖ±‰∫´Êé•Âè£

Android 8.1 (API level 27) introduces a new SharedMemory API. This class allows you to create, map, and manage an anonymous SharedMemory instance. You set the memory protection on a SharedMemory object for reading and/or writing, and, since the SharedMemory object is Parcelable, you can easily pass it to another process through AIDL.

The SharedMemory API interoperates with the ASharedMemory facility in the NDK. ASharedMemory gives access to a file descriptor, which can then be mapped to read and write. It's a great way to share large amounts of data between apps or between multiple processes within a single app.

## Â¢ôÁ∫∏È¢úËâ≤Êé•Âè£

Android 8.1 (API level 27) allows your live wallpaper to provide color information to the system UI. You do this by creating a WallpaperColors object from a bitmap, a drawable, or by using three manually-selected colors. You can also retrieve this color information.

To create a WallpaperColors object, do either of the following:

To create a WallpaperColors object by using three colors, create an instance of the WallpaperColors class by passing the primary, the secondary, and the tertiary color. The primary color must not be null.

- To create a WallpaperColors object from a bitmap, call the fromBitmap() method by passing the bitmap source as parameter.

- To create a WallpaperColors object from a drawable, call the fromDrawable() method by passing the drawable source as parameter.

- To retrieve the primary, secondary, or tertiary color details from the wallpaper, call the following methods:

- getPrimaryColor() returns the most visually-representativecolor of the wallpaper.

- getSecondaryColor() returns the second most preeminent color of the wallpaper.

- getTertiaryColor() method returns the third most preeminent color of the wallpaper.

To notify the system about any significant color changes in your live wallpaper, call the notifyColorsChanged() method. This method triggers an onComputeColors() lifecycle event where you have an opportunity to provide a new WallpaperColors object.

To add a listener for color changes, you can call the addOnColorsChangedListener() method. You can also call the getWallpaperColors() method to retrieve the primary colors of a wallpaper.

## ÊåáÁ∫πÂçáÁ∫ß

The FingerprintManager class has introduced the following error codes:

- FINGERPRINT_ERROR_LOCKOUT_PERMANENT ‚Äì The user has tried too many times to unlock their device using the fingerprint reader.

- FINGERPRINT_ERROR_VENDOR ‚Äì A vendor-specific fingerprint reader error occurred.

## Âä†ÂØÜÂçáÁ∫ß

A number of cryptography changes have been made with Android 8.1:

- New algorithms have been implemented in Conscrypt. The Conscrypt implementation is preferentially used over the existing Bouncy Castle implementation. New algorithms include:
- - AlgorithmParameters:GCM

- - KeyGenerator:AES

- - KeyGenerator:DESEDE

- - KeyGenerator:HMACMD5

- - KeyGenerator:HMACSHA1

- - KeyGenerator:HMACSHA224

- - KeyGenerator:HMACSHA256

- - KeyGenerator:HMACSHA384

- - KeyGenerator:HMACSHA512

- - SecretKeyFactory:DESEDE

- - Signature:NONEWITHECDSA

- Cipher.getParameters().getParameterSpec(IvParameterSpec.class) no longer works for algorithms that use GCM. Instead, use getParameterSpec(GCMParameterSpec.class).

- Many internal Conscrypt classes associated with TLS were refactored. Since developers sometimes access these reflectively, shims have been left in place to support previous usage, but some details have changed. For example, sockets previously were of type OpenSSLSocketImpl, but now they‚Äôre of type ConscryptFileDescriptorSocket or ConscryptEngineSocket, both of which extend OpenSSLSocketImpl.

- SSLSession methods used to throw IllegalArgumentException when passed a null reference, they now throw NullPointerException.

- The RSA KeyFactory no longer allows generation of keys from byte arrays that are larger than the encoded key. Calls to generatePrivate() and generatePublic() that provide a KeySpec where the key structure does not fill the entire buffer will result in an InvalidKeySpecException.

- When a socket read is interrupted by the socket being closed, Conscrypt used to return -1 from the read. The read now throws SocketException.

- The set of root CA certificates has been changed, mostly removing a large number of obsolete certificates, but also removing the root certificates for WoSign and StartCom. For more information on this decision, see the Google Security Blog post, Final removal of trust in WoSign and StartCom Certificates.